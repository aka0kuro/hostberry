{% extends "base.html" %}

{% block content %}
<div class="dashboard-container">
    <!-- Header Section -->
    <div class="dashboard-header mb-4">
        <div class="row align-items-center">
            <div class="col-12 text-center">
                <h1 class="dashboard-title">
                    <i class="bi bi-hdd-network me-2"></i>
                    {{ t('navigation.backup', 'Backup') }}
                </h1>
                <p class="dashboard-subtitle">{{ t('backup.subtitle', 'Gestiona y restaura tus respaldos del sistema') }}</p>
                <div class="dashboard-time">
                    <i class="bi bi-clock me-1"></i>
                    {{ t('backup.last_check', 'Última verificación') }}: <span id="backup-last-check">--</span>
                </div>
            </div>
        </div>
    </div>



    <!-- Quick Actions -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="actions-card">
                <div class="actions-card-header">
                    <h5 class="actions-card-title">
                        <i class="bi bi-lightning-charge me-2"></i>
                        {{ t('backup.actions_heading', 'Acciones de backup') }}
                    </h5>
                </div>
                <div class="actions-card-body">
                    <div class="quick-actions">
                        <button class="action-btn action-backup" id="action-create-backup">
                            <i class="bi bi-hdd-network"></i>
                            <span>{{ t('backup.create_backup', 'Crear backup') }}</span>
                        </button>
                        <button type="button" class="action-btn action-backup" id="action-upload-backup" onclick="document.getElementById('backup-file-input').click();">
                            <i class="bi bi-cloud-upload"></i>
                            <span>{{ t('backup.config_backup', 'Backup de configuración') }}</span>
                        </button>
                        <input type="file" id="backup-file-input" accept=".tar.gz,.tgz" style="display: none;">
                        <button class="action-btn action-backup" id="action-list-backups">
                            <i class="bi bi-archive"></i>
                            <span>{{ t('backup.list_backups', 'Listar backups') }}</span>
                        </button>
                        <button class="action-btn action-backup" id="action-backup-stats">
                            <i class="bi bi-graph-up"></i>
                            <span>{{ t('backup.stats', 'Estadísticas') }}</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Backup Inventory -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="actions-card">
                <div class="actions-card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h5 class="actions-card-title">
                                <i class="bi bi-archive me-2"></i>
                                {{ t('backup.inventory_heading', 'Inventario de backups') }}
                            </h5>
                            <p class="text-white-50 mb-0 small">{{ t('backup.inventory_caption', 'Últimos backups almacenados en el dispositivo') }}</p>
                        </div>
                        <button class="btn btn-sm btn-outline-light" id="backupsListRefresh">
                            <i class="bi bi-arrow-clockwise"></i>
                        </button>
                    </div>
                </div>
                <div class="actions-card-body">
                    <div class="backup-list" id="security-backup-list">
                        <div class="text-center py-4 text-white-50">
                            <i class="bi bi-database"></i>
                            <p class="mb-0 mt-2">{{ t('backup.no_backups', 'Aún no hay backups listados') }}</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Cargar traducciones de backup desde el JSON embebido o API
(function() {
  // Función mejorada para cargar traducciones
  async function loadBackupTranslations() {
    try {
      // 1. Intentar cargar desde el JSON embebido
      const i18nEl = document.getElementById('i18n-json');
      let translations = {};
      
      if (i18nEl) {
        try {
          translations = JSON.parse(i18nEl.textContent || i18nEl.innerText || '{}');
        } catch (e) {
          console.warn('Error parsing i18n-json:', e);
        }
      }
      
      // 2. Si no hay traducciones de backup en el JSON embebido, cargar desde la API
      if (!translations.backup && HostBerry && HostBerry.apiRequest) {
        try {
          // Obtener el idioma actual desde la cookie o del HTML
          const lang = document.documentElement.lang || 'es';
          const resp = await HostBerry.apiRequest(`/api/v1/translations/${lang}`);
          if (resp && resp.ok) {
            const data = await resp.json();
            if (data && data.translations) {
              translations = data.translations;
            }
          }
        } catch (e) {
          console.warn('Error loading translations from API:', e);
        }
      }
      
      // 3. Asegurar que las traducciones estén disponibles
      if (translations.backup) {
        // Asegurar que HostBerry.t puede acceder a las traducciones
        if (!window.HostBerry) window.HostBerry = {};
        if (!window.HostBerry.translations) window.HostBerry.translations = {};
        window.HostBerry.translations.backup = translations.backup;
        
        // También actualizar el objeto translations en common.js
        if (!window.translations) window.translations = {};
        window.translations.backup = translations.backup;
        
        // Actualizar el JSON embebido si existe
        if (i18nEl && !i18nEl.textContent.includes('backup')) {
          try {
            const current = JSON.parse(i18nEl.textContent || '{}');
            current.backup = translations.backup;
            i18nEl.textContent = JSON.stringify(current);
          } catch (e) {
            // Ignorar errores al actualizar
          }
        }
      }
    } catch (e) {
      console.error('Error loading backup translations:', e);
    }
  }
  
  // Cargar traducciones cuando el DOM esté listo
  function initTranslations() {
    // Esperar un poco para que common.js se cargue primero
    setTimeout(loadBackupTranslations, 200);
    
    // Recargar traducciones cuando cambie el idioma
    const langDropdown = document.querySelector('.lang-dropdown');
    if (langDropdown) {
      langDropdown.addEventListener('click', (e) => {
        const link = e.target.closest('a');
        if (link && link.href.includes('lang=')) {
          // Recargar traducciones después de cambiar el idioma
          setTimeout(loadBackupTranslations, 500);
        }
      });
    }
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTranslations);
  } else {
    initTranslations();
  }
})();
</script>
<script>
(function(){
  // Mejorar la función t para que busque en múltiples lugares
  function getTranslation(key, defaultValue) {
    if (!key) return defaultValue || '';
    
    const keys = String(key).split('.');
    
    // 1. Intentar desde HostBerry.translations (más confiable)
    if (window.HostBerry?.translations) {
      let current = window.HostBerry.translations;
      for (const k of keys) {
        if (current && typeof current === 'object' && k in current) {
          current = current[k];
        } else {
          current = null;
          break;
        }
      }
      if (typeof current === 'string' && current) return current;
    }
    
    // 2. Intentar desde window.translations (common.js)
    if (window.translations) {
      let current = window.translations;
      for (const k of keys) {
        if (current && typeof current === 'object' && k in current) {
          current = current[k];
        } else {
          current = null;
          break;
        }
      }
      if (typeof current === 'string' && current) return current;
    }
    
    // 3. Intentar desde el JSON embebido
    try {
      const i18nEl = document.getElementById('i18n-json');
      if (i18nEl) {
        const translations = JSON.parse(i18nEl.textContent || i18nEl.innerText || '{}');
        let current = translations;
        for (const k of keys) {
          if (current && typeof current === 'object' && k in current) {
            current = current[k];
          } else {
            current = null;
            break;
          }
        }
        if (typeof current === 'string' && current) return current;
      }
    } catch (e) {
      // Ignorar errores
    }
    
    // 4. Usar HostBerry.t si está disponible
    if (window.HostBerry?.t) {
      try {
        const result = window.HostBerry.t(key, defaultValue);
        if (result && result !== key && typeof result === 'string') return result;
      } catch (e) {
        // Ignorar errores
      }
    }
    
    // 5. Fallback al valor por defecto
    return defaultValue || key;
  }
  
  // Sobrescribir HostBerry.t si no funciona correctamente
  if (!window.HostBerry) window.HostBerry = {};
  const originalT = window.HostBerry.t;
  window.HostBerry.t = function(key, defaultValue) {
    const result = getTranslation(key, defaultValue);
    if (result && result !== key) return result;
    if (originalT) return originalT(key, defaultValue);
    return defaultValue || key;
  };
  
  const setBadge = (id, enabled) => {
    const el = document.getElementById(id);
    if(!el) return;
    const isOn = !!enabled;
    const enabledText = getTranslation('security.enabled', 'Enabled');
    const disabledText = getTranslation('security.disabled', 'Disabled');
    el.className = 'badge ' + (isOn ? 'bg-success' : 'bg-danger');
    el.textContent = isOn ? enabledText : disabledText;
  };

  const setStatusCard = (idPrefix, enabled) => {
    const badgeEl = document.getElementById(idPrefix + '-badge');
    if(badgeEl) {
      const badge = badgeEl.querySelector('.badge');
      if(badge) {
        badge.className = 'badge ' + (enabled ? 'bg-success' : 'bg-danger');
        badge.textContent = enabled 
          ? getTranslation('security.enabled', 'Enabled')
          : getTranslation('security.disabled', 'Disabled');
      }
    }
  };

  const setText = (id, value) => {
    const el = document.getElementById(id);
    if(el){ el.textContent = value; }
  };

  function updateLastCheck(){
    setText('backup-last-check', new Date().toLocaleString());
  }


  // Función de notificaciones como en dashboard
  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.innerHTML = `
      <div class="notification-content">
        <span class="notification-message">${message}</span>
        <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
      </div>
    `;
    
    if (!document.querySelector('#notification-styles')) {
      const style = document.createElement('style');
      style.id = 'notification-styles';
      style.textContent = `
        .notification {
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 9999;
          min-width: 300px;
          padding: 1rem;
          border-radius: 12px;
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.2);
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
          animation: slideInRight 0.3s ease;
        }
        .notification-content {
          display: flex;
          justify-content: space-between;
          align-items: center;
          color: #fff;
        }
        .notification-close {
          background: none;
          border: none;
          color: #fff;
          font-size: 1.2rem;
          cursor: pointer;
          padding: 0;
          margin-left: 1rem;
        }
        .notification-success { border-left: 4px solid #198754; }
        .notification-error { border-left: 4px solid #dc3545; }
        .notification-warning { border-left: 4px solid #ffc107; }
        .notification-info { border-left: 4px solid #0dcaf0; }
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        body.light-theme .notification {
          background: rgba(255, 255, 255, 0.95);
          color: #212529;
          border: 1px solid rgba(0, 0, 0, 0.1);
        }
        body.light-theme .notification-content {
          color: #212529;
        }
        body.light-theme .notification-close {
          color: #212529;
        }
      `;
      document.head.appendChild(style);
    }
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      if (notification.parentElement) {
        notification.remove();
      }
    }, 5000);
  }

  async function createBackup(){
    try{
      const confirmMsg = getTranslation('backup.create_confirm', 'Are you sure you want to create a backup?');
      if(!confirm(confirmMsg)) return;
      
      showNotification(getTranslation('backup.creating', 'Creating backup...'), 'info');
      
      const resp = await HostBerry.apiRequest('/api/v1/security/backup?include_logs=true&include_uploads=true', { method: 'POST' });
      if(!resp.ok){
        const errorText = await resp.text();
        throw new Error(errorText || getTranslation('backup.create_failed', 'Error creating backup'));
      }
      const payload = await resp.json();
      const message = payload.message || payload.data?.message || getTranslation('backup.created', 'Backup created successfully');
      showNotification(message, 'success');
      updateLastCheck();
      await loadBackups();
    }catch(error){
      console.error('Backup failed', error);
      const errorMsg = getTranslation('backup.create_error', 'Error creating backup');
      showNotification(errorMsg, 'error');
    }
  }

  async function loadBackups(){
    const list = document.getElementById('security-backup-list');
    if(!list) return;
    
    // Mostrar indicador de carga
    const isLoading = list.querySelector('.loading-indicator');
    if(!isLoading){
      list.innerHTML = `
        <div class="text-center py-4 text-white-50 loading-indicator">
          <div class="spinner-border spinner-border-sm me-2" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
          <span>${getTranslation('backup.loading', 'Loading backups...')}</span>
        </div>`;
    }
    
    try{
      const resp = await HostBerry.apiRequest('/api/v1/security/backups');
      if(!resp.ok) throw new Error(getTranslation('backup.load_failed', 'Error loading backups'));
      const payload = await resp.json();
      const backups = payload.data?.backups || payload.backups || [];
      if(!backups.length){
        list.innerHTML = `
          <div class="text-center py-4 text-white-50">
            <i class="bi bi-archive"></i>
            <p class="mb-0 mt-2">${getTranslation('backup.no_backups', 'No backups listed yet')}</p>
          </div>`;
        return;
      }
      list.innerHTML = '';
      backups.slice(0, 10).forEach(backup => {
        const item = document.createElement('div');
        item.className = 'backup-item text-white';
        const name = backup.name || backup.filename || backup.path || (typeof backup === 'string' ? backup : 'backup');
        // Obtener tamaño del archivo real si no está en el objeto
        const size = backup.size ? formatBytes(backup.size) : (backup.size_bytes ? formatBytes(backup.size_bytes) : '');
        const date = backup.created_at || backup.timestamp || backup.date || backup.created || '';
        const formattedDate = date ? new Date(date).toLocaleString() : '';
        item.innerHTML = `
          <div class="d-flex justify-content-between align-items-center gap-3">
            <div class="flex-grow-1 min-w-0">
              <div class="d-flex align-items-center gap-2 mb-1">
                <i class="bi bi-file-earmark-zip text-primary"></i>
                <strong class="backup-name" title="${name}">${name}</strong>
              </div>
              <div class="d-flex align-items-center gap-3 text-white-50 small">
                ${formattedDate ? `<span><i class="bi bi-calendar3 me-1"></i>${formattedDate}</span>` : ''}
                ${size ? `<span><i class="bi bi-hdd me-1"></i>${size}</span>` : `<span class="text-warning"><i class="bi bi-exclamation-triangle me-1"></i>${getTranslation('backup.size_not_available', 'Size not available')}</span>`}
              </div>
            </div>
            <div class="d-flex align-items-center gap-3 flex-shrink-0" style="margin-left: auto;">
              <button class="btn btn-sm btn-outline-info info-backup-btn" data-backup-name="${name}" title="${getTranslation('backup.info', 'Information')}">
                <i class="bi bi-info-circle"></i>
              </button>
              <button class="btn btn-sm btn-outline-primary download-backup-btn" data-backup-name="${name}" title="${getTranslation('backup.download', 'Download')}">
                <i class="bi bi-download"></i>
              </button>
              <button class="btn btn-sm btn-outline-warning restore-backup-btn" data-backup-name="${name}" title="${getTranslation('backup.restore', 'Restore')}">
                <i class="bi bi-arrow-clockwise"></i>
              </button>
              <button class="btn btn-sm btn-outline-danger delete-backup-btn" data-backup-name="${name}" title="${getTranslation('backup.delete', 'Delete')}">
                <i class="bi bi-trash"></i>
              </button>
            </div>
          </div>`;
        list.appendChild(item);
      });
      
      // Agregar event listeners a los botones
      document.querySelectorAll('.info-backup-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const backupName = btn.getAttribute('data-backup-name');
          showBackupInfo(backupName);
        });
      });
      
      document.querySelectorAll('.download-backup-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const backupName = btn.getAttribute('data-backup-name');
          downloadBackup(backupName);
        });
      });
      
      document.querySelectorAll('.restore-backup-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const backupName = btn.getAttribute('data-backup-name');
          restoreBackup(backupName);
        });
      });
      
      document.querySelectorAll('.delete-backup-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const backupName = btn.getAttribute('data-backup-name');
          deleteBackup(backupName);
        });
      });
    }catch(error){
      console.error('Backups load failed', error);
      list.innerHTML = `
        <div class="text-center py-4 text-danger">
          <i class="bi bi-exclamation-triangle"></i>
          <p class="mb-0 mt-2">${getTranslation('backup.load_error', 'Error loading backups')}</p>
        </div>`;
    }
  }

  function formatBytes(bytes){
    if(!bytes || bytes === 0) return '';
    const k = 1024;
    const sizes = [
      getTranslation('backup.bytes', 'Bytes'),
      getTranslation('backup.kb', 'KB'),
      getTranslation('backup.mb', 'MB'),
      getTranslation('backup.gb', 'GB')
    ];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  }


  async function downloadBackup(backupName){
    try{
      if(!backupName){
        showNotification(getTranslation('backup.not_found', 'Backup not found'), 'error');
        return;
      }
      
      showNotification(getTranslation('backup.downloading', 'Downloading backup...'), 'info');
      
      // Usar fetch con autenticación para descargar
      const token = localStorage.getItem('access_token');
      const downloadUrl = `/api/v1/security/backup/${encodeURIComponent(backupName)}/download`;
      
      const resp = await fetch(downloadUrl, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if(!resp.ok){
        throw new Error(`Error ${resp.status}: ${resp.statusText}`);
      }
      
      // Obtener el blob del archivo
      const blob = await resp.blob();
      
      // Crear enlace de descarga
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = backupName;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      
      // Mostrar mensaje de éxito
      showNotification(getTranslation('backup.downloaded', 'Backup downloaded successfully'), 'success');
      updateLastCheck();
      
    }catch(error){
      console.error('Backup download failed', error);
      showNotification(getTranslation('backup.download_error', 'Error downloading backup'), 'error');
    }
  }

  async function uploadBackup(file){
    try{
      if(!file){
        showNotification(getTranslation('backup.no_file', 'No file selected'), 'error');
        return;
      }
      
      // Validar extensión
      if(!file.name.endsWith('.tar.gz') && !file.name.endsWith('.tgz')){
        showNotification(getTranslation('backup.invalid_format', 'File must be a .tar.gz backup'), 'error');
        return;
      }
      
      showNotification(getTranslation('backup.uploading', 'Uploading backup...'), 'info');
      
      const formData = new FormData();
      formData.append('file', file);
      
      // Usar fetch directamente para FormData (no establecer Content-Type, el navegador lo hace automáticamente)
      const token = localStorage.getItem('access_token');
      const resp = await fetch('/api/v1/security/backup/upload', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        },
        body: formData
      });
      
      if(!resp.ok){
        let errorData;
        try {
          errorData = await resp.json();
        } catch {
          const errorText = await resp.text();
          errorData = { detail: errorText };
        }
        throw new Error(errorData.detail || errorData.message || (getTranslation('backup.upload_failed', 'Error uploading backup')));
      }
      
      const payload = await resp.json();
      const message = payload.message || payload.data?.message || getTranslation('backup.uploaded', 'Backup uploaded successfully');
      showNotification(message, 'success');
      updateLastCheck();
      await loadBackups();
      
    }catch(error){
      console.error('Backup upload failed', error);
      let errorMsg = getTranslation('backup.upload_error', 'Error uploading backup');
      // Mostrar mensaje de error más específico si está disponible
      if(error.message && error.message !== 'Error al cargar backup' && error.message !== 'Upload failed'){
        errorMsg = error.message;
      }
      showNotification(errorMsg, 'error');
    }
  }

  async function restoreBackup(backupName){
    try{
      if(!backupName){
        showNotification(getTranslation('backup.not_found', 'Backup not found'), 'error');
        return;
      }
      
      // Confirmación doble para restauración
      const confirmMsg1 = getTranslation('backup.restore_confirm', 'Are you sure you want to restore this backup? This will replace the current system data.');
      if(!confirm(confirmMsg1)) return;
      
      const confirmMsg2 = getTranslation('backup.restore_confirm_final', 'WARNING! This action will restore the backup and replace current data. Are you absolutely sure?');
      if(!confirm(confirmMsg2)) return;
      
      showNotification(getTranslation('backup.restoring', 'Restoring backup...'), 'warning');
      
      const resp = await HostBerry.apiRequest(`/api/v1/security/backup/${encodeURIComponent(backupName)}/restore`, {
        method: 'POST'
      });
      
      if(!resp.ok){
        const errorText = await resp.text();
        throw new Error(errorText || getTranslation('backup.restore_failed', 'Error restoring backup'));
      }
      
      const payload = await resp.json();
      const message = payload.message || payload.data?.message || getTranslation('backup.restored', 'Backup restored successfully');
      showNotification(message, 'success');
      
      // Recargar la lista de backups después de un momento
      setTimeout(() => {
        loadBackups();
      }, 2000);
      
    }catch(error){
      console.error('Backup restore failed', error);
      const errorMsg = getTranslation('backup.restore_error', 'Error restoring backup');
      showNotification(errorMsg, 'error');
    }
  }

  async function showBackupInfo(backupName){
    try{
      if(!backupName){
        showNotification(getTranslation('backup.not_found', 'Backup not found'), 'error');
        return;
      }
      
      const resp = await HostBerry.apiRequest(`/api/v1/security/backup/${encodeURIComponent(backupName)}`);
      if(!resp.ok) throw new Error(getTranslation('backup.info_failed', 'Error getting information'));
      
      const payload = await resp.json();
      const info = payload.data?.backup_info || payload.backup_info || {};
      
      // Obtener tamaño del archivo real si está disponible
      let sizeText = 'N/A';
      if(info.size){
        sizeText = formatBytes(info.size);
      } else if(info.size_bytes){
        sizeText = formatBytes(info.size_bytes);
      } else {
        // Intentar obtener el tamaño del archivo desde el sistema
        try {
          const backupsResp = await HostBerry.apiRequest('/api/v1/security/backups');
          if(backupsResp.ok){
            const backupsData = await backupsResp.json();
            const backups = backupsData.data?.backups || backupsData.backups || [];
            const backup = backups.find(b => (b.name || b.filename) === backupName);
            if(backup && backup.size){
              sizeText = formatBytes(backup.size);
            }
          }
        } catch(e) {
          console.error('Error getting backup size:', e);
        }
      }
      
      const dateText = info.created_at || info.timestamp || info.date || info.created || 'N/A';
      const formattedDate = dateText !== 'N/A' ? new Date(dateText).toLocaleString() : 'N/A';
      
      const infoText = `${getTranslation('backup.name', 'Name')}: ${backupName} | ${getTranslation('backup.size', 'Size')}: ${sizeText} | ${getTranslation('backup.created', 'Created')}: ${formattedDate}`;
      
      showNotification(infoText, 'info');
    }catch(error){
      console.error('Backup info failed', error);
      showNotification(getTranslation('backup.info_error', 'Error getting information'), 'error');
    }
  }

  async function deleteBackup(backupName){
    try{
      if(!backupName){
        showNotification(getTranslation('backup.not_found', 'Backup not found'), 'error');
        return;
      }
      
      const confirmMsg = getTranslation('backup.delete_confirm', 'Are you sure you want to delete this backup?');
      if(!confirm(confirmMsg)) return;
      
      showNotification(getTranslation('backup.deleting', 'Deleting backup...'), 'info');
      
      const token = localStorage.getItem('access_token');
      const resp = await fetch(`/api/v1/security/backup/${encodeURIComponent(backupName)}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if(!resp.ok){
        let errorData;
        try {
          errorData = await resp.json();
        } catch {
          const errorText = await resp.text();
          errorData = { detail: errorText };
        }
        throw new Error(errorData.detail || errorData.message || getTranslation('backup.delete_failed', 'Error deleting backup'));
      }
      
      const payload = await resp.json();
      const message = payload.message || payload.data?.message || getTranslation('backup.deleted', 'Backup deleted successfully');
      showNotification(message, 'success');
      updateLastCheck();
      
      // Recargar la lista de backups
      setTimeout(() => {
        loadBackups();
      }, 1000);
      
    }catch(error){
      console.error('Backup delete failed', error);
      showNotification(getTranslation('backup.delete_error', 'Error deleting backup'), 'error');
    }
  }

  async function showBackupStats(){
    try{
      const resp = await HostBerry.apiRequest('/api/v1/security/backups');
      if(!resp.ok) throw new Error(getTranslation('backup.stats_failed', 'Error getting statistics'));
      
      const payload = await resp.json();
      const backups = payload.data?.backups || payload.backups || [];
      
      const totalBackups = backups.length;
      const totalSize = backups.reduce((sum, b) => sum + (b.size || 0), 0);
      const oldestBackup = backups.length > 0 ? backups[backups.length - 1] : null;
      const newestBackup = backups.length > 0 ? backups[0] : null;
      
      const statsText = `${getTranslation('backup.total', 'Total backups')}: ${totalBackups} | ${getTranslation('backup.total_size', 'Total size')}: ${formatBytes(totalSize)}${oldestBackup ? ` | ${getTranslation('backup.oldest', 'Oldest')}: ${oldestBackup.name || oldestBackup.filename || 'N/A'}` : ''}${newestBackup ? ` | ${getTranslation('backup.newest', 'Newest')}: ${newestBackup.name || newestBackup.filename || 'N/A'}` : ''}`;
      
      showNotification(statsText, 'info');
    }catch(error){
      console.error('Backup stats failed', error);
      showNotification(getTranslation('backup.stats_error', 'Error getting statistics'), 'error');
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    // Actualizar última verificación inmediatamente (no bloquea)
    updateLastCheck();
    
    // NO cargar backups automáticamente - solo cuando el usuario lo solicite
    // Mostrar mensaje inicial
    const list = document.getElementById('security-backup-list');
    if(list){
      list.innerHTML = `
        <div class="text-center py-4 text-white-50">
          <i class="bi bi-archive"></i>
          <p class="mb-0 mt-2">${getTranslation('backup.click_to_load', 'Click "List backups" to load backups')}</p>
        </div>`;
    }
    
    // Configurar event listeners
    document.getElementById('backupsListRefresh')?.addEventListener('click', () => {
      showNotification(getTranslation('backup.loading', 'Loading backups...'), 'info');
      loadBackups();
    });
    document.getElementById('action-create-backup')?.addEventListener('click', createBackup);
    document.getElementById('action-list-backups')?.addEventListener('click', () => {
      showNotification(getTranslation('backup.loading', 'Loading backups...'), 'info');
      loadBackups();
    });
    document.getElementById('action-backup-stats')?.addEventListener('click', showBackupStats);
    
    // Manejar carga de archivo
    const fileInput = document.getElementById('backup-file-input');
    if(fileInput){
      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(file){
          uploadBackup(file);
          // Resetear input
          e.target.value = '';
        }
      });
    }
    
    // NO actualizar automáticamente - solo cuando el usuario lo solicite
  });
})();
</script>
<style>
.spinning {
    animation: spin 1s linear infinite;
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.log-item {
    padding: 0.75rem 1rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    display: flex;
    gap: 1rem;
    align-items: center;
    margin-bottom: 0.75rem;
}
.log-item:last-child {
    margin-bottom: 0;
}
.log-level {
    min-width: 80px;
    text-transform: uppercase;
    font-size: 0.7rem;
}
.backup-item {
    padding: 0.75rem 1rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    margin-bottom: 0.75rem;
    transition: all 0.3s ease;
}
.backup-item:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.1);
}
.backup-item:last-child {
    margin-bottom: 0;
}
.backup-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100%;
    word-break: break-all;
}
.backup-item .min-w-0 {
    min-width: 0;
}
.backup-item .flex-shrink-0 {
    flex-shrink: 0;
}
.logs-container {
    max-height: 380px;
    overflow-y: auto;
}
/* Estilos para botones de backup - iguales al dashboard */
.quick-actions {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
}

body.light-theme .action-btn {
    background: rgba(0, 0, 0, 0.05);
    color: #212529;
    border: 1px solid rgba(0, 0, 0, 0.1);
}

body.light-theme .action-btn:hover {
    background: rgba(0, 0, 0, 0.1);
    border-color: rgba(0, 0, 0, 0.2);
}

.backup-item {
    padding: 1rem 1.25rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    margin-bottom: 0.75rem;
    transition: all 0.3s ease;
}

.backup-item:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(255, 255, 255, 0.15);
    transform: translateX(4px);
}

.backup-item:last-child {
    margin-bottom: 0;
}

.backup-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100%;
    word-break: break-all;
    font-size: 0.95rem;
}

.backup-item .min-w-0 {
    min-width: 0;
}

.backup-item .flex-shrink-0 {
    flex-shrink: 0;
}
</style>
{% endblock %}
